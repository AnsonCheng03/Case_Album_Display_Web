import{p as T,o as F,q as G,v as J,n as K,m as L,r as X,w as Y,l as Z,x as f,y as d,z as $,A as tt,B as et}from"./root_component_3sccycdd1z0.js";import{v as ot,y as nt,x as at,n as rt,z as it}from"./root2.js";import{A as pt}from"./root2.js";import{c as H,m as U,r as x}from"./@qwik-city-plan.js";const dt=({track:j})=>{const[z,A,M,s,lt,I,N,q,O,w,c]=ot();async function V(){var P;const[m,k]=j(()=>[w.value,z.value]),W=nt(""),y=c.url,r=k?"form":m.type,B=m.replaceState;let o,p,E=null,_;{o=new URL(m.dest,location),o.pathname.endsWith("/")||(o.pathname+="/");let S=T(x,U,H,o.pathname);_=at();const v=p=await F(o,_,{action:k,clearCache:!0});if(!v){w.untrackedValue={type:r,dest:o};return}const C=v.href,b=new URL(C,o);G(b,o)||(o=b,S=T(x,U,H,o.pathname));try{E=await S}catch{window.location.href=C;return}}if(E){const[S,v,C,b]=E,h=C,Q=h[h.length-1];c.prevUrl=y,c.url=o,c.params={...v},w.untrackedValue={type:r,dest:o};const u=J(p,c,h,W);A.headings=Q.headings,A.menu=b,M.value=rt(h),s.links=u.links,s.meta=u.meta,s.styles=u.styles,s.scripts=u.scripts,s.title=u.title,s.frontmatter=u.frontmatter;{O.viewTransition!==!1&&(document.__q_view_transition__=!0);let D;r==="popstate"&&(D=K()),(m.scroll&&(!m.forceReload||!L(o,y))&&(r==="link"||r==="popstate")||r==="form"&&!L(o,y))&&(document.__q_scroll_restore__=()=>X(r,o,y,D));const R=p==null?void 0:p.loaders,t=window;if(R&&Object.assign(N,R),Y.clear(),!t._qCitySPA){if(t._qCitySPA=!0,history.scrollRestoration="manual",t.addEventListener("popstate",()=>{t._qCityScrollEnabled=!1,clearTimeout(t._qCityScrollDebounce),I(location.href,{type:"popstate"})}),t.removeEventListener("popstate",t._qCityInitPopstate),t._qCityInitPopstate=void 0,!t._qCityHistoryPatch){t._qCityHistoryPatch=!0;const n=history.pushState,i=history.replaceState,l=e=>(e===null||typeof e>"u"?e={}:(e==null?void 0:e.constructor)!==Object&&(e={_data:e},console.warn("In a Qwik SPA context, `history.state` is used to store scroll state. Direct calls to `pushState()` and `replaceState()` must supply an actual Object type. We need to be able to automatically attach the scroll state to your state object. A new state object has been created, your data has been moved to: `history.state._data`")),e._qCityScroll=e._qCityScroll||d(document.documentElement),e);history.pushState=(e,a,g)=>(e=l(e),n.call(history,e,a,g)),history.replaceState=(e,a,g)=>(e=l(e),i.call(history,e,a,g))}document.body.addEventListener("click",n=>{if(n.defaultPrevented)return;const i=n.target.closest("a[href]");if(i&&!i.hasAttribute("preventdefault:click")){const l=i.getAttribute("href"),e=new URL(location.href),a=new URL(l,e);if(Z(a,e)&&L(a,e)){if(n.preventDefault(),!a.hash&&!a.href.endsWith("#")){a.href!==e.href&&history.pushState(null,"",a),t._qCityScrollEnabled=!1,clearTimeout(t._qCityScrollDebounce),f({...d(document.documentElement),x:0,y:0}),location.reload();return}I(i.getAttribute("href"))}}}),document.body.removeEventListener("click",t._qCityInitAnchors),t._qCityInitAnchors=void 0,window.navigation||(document.addEventListener("visibilitychange",()=>{if(t._qCityScrollEnabled&&document.visibilityState==="hidden"){const n=d(document.documentElement);f(n)}},{passive:!0}),document.removeEventListener("visibilitychange",t._qCityInitVisibility),t._qCityInitVisibility=void 0),t.addEventListener("scroll",()=>{t._qCityScrollEnabled&&(clearTimeout(t._qCityScrollDebounce),t._qCityScrollDebounce=setTimeout(()=>{const n=d(document.documentElement);f(n),t._qCityScrollDebounce=void 0},200))},{passive:!0}),removeEventListener("scroll",t._qCityInitScroll),t._qCityInitScroll=void 0,(P=t._qCityBootstrap)==null||P.remove(),t._qCityBootstrap=void 0,$.resolve()}if(r!=="popstate"){t._qCityScrollEnabled=!1,clearTimeout(t._qCityScrollDebounce);const n=d(document.documentElement);f(n)}tt(window,r,y,o,B),it(_).then(()=>{var l;et(_).setAttribute("q:route",S);const i=d(document.documentElement);f(i),t._qCityScrollEnabled=!0,c.isNavigating=!1,(l=q.r)==null||l.call(q)})}}}V()};export{dt as QwikCityProvider_component_useTask_02wMImzEAbk,pt as _hW};
